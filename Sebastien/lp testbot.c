#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  shaftencoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, reversed, encoderPort, None)
#pragma config(Motor,  port9,           leftMotor,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float ticksToMM(int ticks){
	//return ticks * 0.304778121;
	float inchInMM = 25.4;
	float ticksPerRotation = 360.0;
	float diameter = 2.75;
	float mmPerTick = (diameter * inchInMM) * PI / ticksPerRotation;
	return ticks * mmPerTick;

}

int distToPower(float dist, float target) {
	float fade = 200.0;
	int maxPower = 100;
	int lowPower = 20;
	int power = maxPower;
	if (dist > (target - fade)) {
		power = ((maxPower - lowPower) * ((target - dist) / fade )) + lowPower;
	}
	return power;
}

void forwardToDistance(float target)
{
	SensorValue[shaftencoder] = 0;
	float dist = 0;

	while(dist < target)  // While less than 5 rotations on the leftEncoder...
	{
		dist = ticksToMM(SensorValue[shaftencoder]);
		int power = distToPower(dist, target);
		motor[leftMotor] = power; //Full power is 127
		motor[rightMotor] = power; //Full power is 127
	}
	motor[leftMotor] = 0; //Full power is 127
	motor[rightMotor] = 0; //Full power is 127
}

void turnLeft(int duration){
	motor[rightMotor] = 127;
	motor[leftMotor] = -127;

	wait1Msec(duration);
	motor[leftMotor] = 0; //Full power is 127
	motor[rightMotor] = 0; //Full power is 127

}

void turnRight(int duration){\
	motor[rightMotor] = -127;
	motor[leftMotor] = 127;

	wait1Msec(duration);
	motor[leftMotor] = 0; //Full power is 127
	motor[rightMotor] = 0; //Full power is 127

}

/*



int angularDist(int to, int from){
  //normalisedDist = ((to % 360) - (from % 360)) % 360;
  int normalisedDist = ((to) - (from )) % 3600;
  int shortest = normalisedDist;
  if((normalisedDist) > 1800){
    shortest = (normalisedDist - 3600);
  }

  if(abs(shortest) > 1800){
    shortest = (shortest + 3600) % 3600;
  }

  return shortest;
}

int getTurnPower(int angleToTurn){
  int remaining = abs(angleToTurn);
  int maxPower = 40;//127;
  int turnLowPower = 0;
  int fadeAngle = 200;
  int power = maxPower;
  if(remaining < fadeAngle){
    power = floor(((maxPower - turnLowPower) * (remaining / fadeAngle)) + turnLowPower);
  }
  return power;
}

void turnTo(int to){
	int from = SensorValue[gyro];
	int angleToTurn = angularDist(to, from);
	bool turning = true;
	while(turning)  // more than 3 degrees out.
	{
		angleToTurn = angularDist(to, from);
		int power = getTurnPower(angleToTurn);

		if(angleToTurn >= 0){
			motor[leftMotor] = power; //Full power is 127
			motor[rightMotor] = -power; //Full power is 127
		}
		 else {
			motor[leftMotor] = -power; //Full power is 127
			motor[rightMotor] = power; //Full power is 127
		}

		wait1Msec(1);
		from = SensorValue[gyro];
		angleToTurn = angularDist(to, from);
		int mag = abs(angleToTurn);
		turning = abs(angleToTurn) > 100;
	}
	motor[leftMotor] = 0; //Full power is 127
	motor[rightMotor] = 0; //Full power is 127
}

*/

task main()
{
	//while (1==1){
	motor[leftMotor] = 0; //Full power is 127
	motor[rightMotor] = 0; //Full power is 127

//Completely clear out any previous sensor readings by setting the port to "sensorNone"
 SensorType[in8] = sensorNone;
 wait1Msec(1000);
 //Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
 SensorType[in8] = sensorGyro;
 wait1Msec(2000);


	forwardToDistance(100.0);
	turnTo(-450);
	//turnLeft(280);
	//forwardToDistance(900.0);
/*	turnTo(450);

	//turnRight(700);
	///turnTo(900);
	forwardToDistance(900.0);
*/
}
