#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  sonarR,         sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  led,            sensorDigitalOut)
#pragma config(Sensor, dgtl4,  sonarL,         sensorSONAR_cm)
#pragma config(Sensor, dgtl12, pb,             sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           leftF,         tmotorVex393_MC29, PIDControl, driveLeft, encoderPort, I2C_3)
#pragma config(Motor,  port3,           rightF,        tmotorVex393_MC29, PIDControl, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port4,           leftB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightB,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftM,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightM,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm,           tmotorVex393_MC29, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port9,           claw,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

int cmR;
int cmL;

void pick_up() {
	nMotorPIDSpeedCtrl[arm] = mtrSpeedReg;
	setMotorTarget(arm, 0, true);
	while (true) {
		if(vexRT[Btn7D] == 1) {
			break;
		}
		cmR = SensorValue(sonarR);
		cmL = SensorValue(sonarL);

		motor[claw] = -100;

		if(cmR > 7) {
			motor[rightF] = 40;
			} else {
			motor[rightF] = 0;
		}
		if(cmL > 7) {
			motor[leftF] = 40;
			} else {
			motor[leftF] = 0;
		}
		if(cmR < 8 && cmL < 8)
		{
			break;
		}
	}
	while(true) {
		if(vexRT[Btn7D] == 1) {
			break;
		}
		motor[claw] = 100;
		setMotorTarget(arm, 800, 100, true);
		if(getMotorEncoder(arm) >= 750) {

			break;
		}
	}
	nMotorPIDSpeedCtrl[arm] = mtrNoReg;
}

void pole() {
	nMotorPIDSpeedCtrl[arm] = mtrSpeedReg;
	setMotorTarget(arm, 1400, 100, true);
	motor[claw] = 100;
	while (true) {
		if(vexRT[Btn7D] == 1) {
			break;
		}
		cmR = SensorValue(sonarR);
		cmL = SensorValue(sonarL);

		if((cmR + cmL) / 2 > 20) {
			motor[leftF] = 50;
			motor[rightF] = 50;
			} else {
			motor[leftF] = 0;
			motor[rightF] = 0;
			break;
		}
		if(cmL > cmR){
			motor[leftF] = 40;
		}
		if(cmR > cmL) {
			motor[rightF] = 40;
		}
	}
	nMotorPIDSpeedCtrl[arm] = mtrNoReg;
}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*---------------------------------------------------------------------------*/
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;


	slaveMotor(rightM, rightF);
	slaveMotor(rightB, rightF);
	slaveMotor(leftM, leftF);
	slaveMotor(leftB, leftF);

	resetMotorEncoder(arm);
	resetMotorEncoder(rightF);
	resetMotorEncoder(leftF);
}

void turn_right() {
	int rel = SensorValue(gyro);
	while (SensorValue(gyro) - rel > -600) {
		motor[rightF] = -100;
		motor[leftF] = 100;
	}
	motor[rightF] = 0;
	motor[leftF] = 0;
}
void turn_left() {
	int rel = SensorValue(gyro);
	while (SensorValue(gyro) - rel < 600) {
		motor[rightF] = 100;
		motor[leftF] = -100;
	}
	motor[rightF] = 0;
	motor[leftF] = 0;
}

void aim(int angle) { //3600
	if(SensorValue(gyro) % 3600 > angle) {
		while(SensorValue(gyro) % 3600 > angle + 200) {
			motor[rightF] = -100;
			motor[leftF] = 100;
		}
		motor[rightF] = 0;
		motor[leftF] = 0;
		} else {
		while(SensorValue(gyro) % 3600 < angle - 200) {
			motor[rightF] = 100;
			motor[leftF] = -100;
		}
		motor[rightF] = 0;
		motor[leftF] = 0;
	}
}

void forward(int distance, int speed) {
	moveMotorTarget(leftF, distance,speed, false);
	moveMotorTarget(rightF, distance, speed, false);
}

void go_to(int angle, int hyp) {
	aim(angle);
	delay(1000);
	forward(hyp, 100);
}

/*---------------------------------------------------------------------------*/
/*                              Autonomous Task                              */
/*---------------------------------------------------------------------------*/
task autonomous()
{
	nMotorPIDSpeedCtrl[rightF] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[leftF] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[arm] = mtrSpeedReg;

	setMotorTarget(rightF, 0, 127, false);
	setMotorTarget(leftF, 0, 127, false);
	setMotorTarget(arm, 0, 127, false);

	int auto = 0; //0-RL 1-BL 2-RR 3-BR 4-AM

	if(auto == 0) { //Red Left

		moveMotorTarget(leftF, 2000, 100, false);
		moveMotorTarget(rightF, 2000, 100, false);
		setMotorTarget(arm, 300, 50, false);
		delay(4000);
		moveMotorTarget(rightF, -750, 100, false);
		moveMotorTarget(leftF, -750, 100, false);
		setMotorTarget(arm, 200, 100, false);
		delay(1000);
		turn_left();
		motor[claw] = -127;

		delay(3000);
		//moveMotorTarget(leftF, -100, 40, false);
		//moveMotorTarget(rightF, -100, 40, false);

		moveMotorTarget(leftF, 500, 100, false);
		moveMotorTarget(rightF, 500, 100, false);
		delay(2000);
		motor[claw] = 127;
		setMotorTarget(arm, 900, 127, true);
		//motor[arm] = 80;
		//motor[claw] = -127;
		//delay(100);
		//motor[arm] = 20;
		//delay(400);

		//moveMotorTarget(leftF, 500, 100, false);
		//moveMotorTarget(rightF, 500, 100, false);
		delay(1000);

		delay(300);
		//motor[claw] = 50;


		delay(1000);
		moveMotorTarget(rightF, 500, 100, false);
		delay(2000);
		moveMotorTarget(leftF, 1000, 100, false);
		moveMotorTarget(rightF, 1000, 100, false);

		delay(2000);

		moveMotorTarget(leftF, 300, 100, false);

		//moveMotorTarget(rightF, 3000, 100, false);
		//delay(4000);
		//moveMotorTarget(leftF, 2000, 100, false);
		//moveMotorTarget(rightF, 2000, 100, false);
	}

	if(auto == 2){ //Red Right
		moveMotorTarget(leftF, 2100, 100, false);
		moveMotorTarget(rightF, 2100, 100, false);
		moveMotorTarget(arm, 200, 50, true);
		delay(4000);
		moveMotorTarget(rightF, -225, 100, false);
		moveMotorTarget(leftF, -225, 100, false);
		moveMotorTarget(arm, 300, 50, true);
		delay(1000);
		turn_left();

		delay(2000);
		moveMotorTarget(leftF, 1400, 100, false);
		moveMotorTarget(rightF, 1400, 100, false);
	}
}

/*---------------------------------------------------------------------------*/
/*                              User Control Task                            */
/*---------------------------------------------------------------------------*/
task usercontrol()
{
	setMotorTarget(rightF, 0, 127, false);
	setMotorTarget(leftF, 0, 127, false);
	setMotorTarget(arm, 0, 127, false);

	motor[rightF] = 0;
	motor[leftF] = 0;
	motor[rightM] = 0;
	motor[leftM] = 0;
	motor[rightB] = 0;
	motor[leftB] = 0;
	motor[arm] = 0;

	nMotorPIDSpeedCtrl[rightF] = mtrNoReg;
	nMotorPIDSpeedCtrl[leftF] = mtrNoReg;
	nMotorPIDSpeedCtrl[arm] = mtrNoReg;

	while (true)
	{
		// Front Motors
		motor[leftF]  = (vexRT[Ch2] + vexRT[Ch1])/2;  // (y + x)/2
		motor[rightF] = (vexRT[Ch2] - vexRT[Ch1])/2;  // (y - x)/2
		// Back Motors (Slaved) I THINK
		//motor[leftB]  = (vexRT[Ch2] + vexRT[Ch1])/2;  // (y + x)/2
		//motor[rightB] = (vexRT[Ch2] - vexRT[Ch1])/2;  // (y - x)/2
		// Middle Motors (Slaved) I THINK
		//motor[leftM]  = (vexRT[Ch2] - vexRT[Ch1])/2;  // (y + x)/2
		//motor[rightM] = (vexRT[Ch2] - vexRT[Ch1])/2;  // (y - x)/2
		// Claw
		if(vexRT[Btn6U] == 1)
		{
			motor[claw] = 100;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[claw] = -127;
		}
		else
		{
			motor[claw] = 0;
		}
		// Arm
		if(vexRT[Btn5U] == 1)
		{
			motor[arm] = 127;
		}
		else if(vexRT[Btn5D] == 1)
		{
			motor[arm] = -127;
		}
		else
		{
			if(nMotorEncoder[arm] < 1607)
			{
				motor[arm] = 15;
			}
			else if(nMotorEncoder[arm] > 1607)
			{
				motor[arm] = -15;
			}
		}

		// Pneumatics
		if(vexRT[Btn8U] == 1) {
			SensorValue(pb) = 1;
		}
		if(vexRT[Btn8D] == 1) {
			SensorValue(pb) = 0;
		}

		//User Functions
		if(vexRT[Btn7R] == 1) {
			pole();
		}
		if(vexRT[Btn7L]== 1) {
			pick_up();
		}
	}
}
